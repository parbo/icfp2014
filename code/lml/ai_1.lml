;; For reference:
;;  * 0: Wall (`#`)
;;  * 1: Empty (`<space>`)
;;  * 2: Pill
;;  * 3: Power pill
;;  * 4: Fruit location
;;  * 5: Lambda-Man starting position
;;  * 6: Ghost starting position
(letrec (init modulo random opposite map lman lmanvit lmanpos lmandir mapobjdir turncw turnccw mhdist abs dirfrom ghostpos ghostdist flee moves sort transform sortedmoves filterdir filterobj findpills sameasfirst shuffle step mapobj findx nextstep)
  (
   ;; init: returns the seed for the PRG, and the step function
   (lambda (ws unused) (tuple 42 step))
   ;; modulo: is a % b
   (lambda (a b) (- a  (* b (div a b))))
   ;; random: is a pseudo random generator
   (lambda (seed) (modulo (* 75 seed) 65537)) ; same as ZX Spectrum
   ;; opposite: returns the opposite direction
   (lambda (dir)
     (modulo (+ dir 2) 4))
   ;; map: given world state, returns the map
   (lambda (ws) (car ws))
   ;; lman: given world state returns the lambda-man's state
   (lambda (ws) (car (cdr ws)))
   ;; lmanvit: given world state returns the vitality of lambda-man
   (lambda (ws) (car (lman ws)))
   ;; lmanpos: given world state returns the position of lambda-man
   (lambda (ws) (car (cdr (lman ws))))
   ;; lmandir: given world state returns the position of lambda-man
   (lambda (ws) (car (cdr (cdr (lman ws)))))
   ;; mapobjdir: given world state and a direction, returns what's on the map in that direction for lambda-man
   ;; FIXME: something is wrong with this..
   (lambda (ws dir) (mapobj (map ws) (nextstep (lmanpos ws) dir)))
   ;; turncw: given a direction, returns the next clock-wise direction
   (lambda (dir) (let (newdir) ((+ 1 dir))
                      (if (> newdir 3)
                          0
                        newdir)))
   ;; turnccw: given a direction, returns the next counter clock-wise direction
   (lambda (dir) (let (newdir) ((- dir 1))
                      (if (< newdir 0)
                          3
                        newdir)))
   ;; mhdist: given two positions, return manhattan distance
   (lambda (p1 p2)
     (let (x1 y1 x2 y2) ((car p1) (cdr p1) (car p2) (cdr p2))
          (if (> x1 x2)
              (if (> y1 y2)
                  (+ (- x1 x2) (- y1 y2))
                  (+ (- x1 x2) (- y2 y1)))
              (if (> y1 y2)
                  (+ (- x2 x1) (- y1 y2))
                  (+ (- x2 x1) (- y2 y1))))))
   ;; abs: returns absolute value
   (lambda (x)
     (if (< x 0) (* x -1) x))
   ;; dirfrom: given two positions, return a pair of general directions (up, down, left right)
   (lambda (p1 p2)
     (let (x1 y1 x2 y2) ((car p1) (cdr p1) (car p2) (cdr p2))
          (let (xdist ydist) ((- x1 x2) (- y1 y2))
               (tuple (if (> xdist 0) 3 1) (if (> ydist 0) 0 2)))))
   ;; ghostpos: given world state, returns list of ghosts' positions
   (lambda (ws)
     (letrec (ghosts getpos)
       ((car (cdr (cdr ws)))
        (lambda (g)
          (if (atom g)
              g
            (if (eq (car (car g)) 0) ;; standard ghost
                (cons (car (cdr (car g))) ;; The position of the first ghost in the list
                      (getpos (cdr g)))
              (getpos (cdr g))))))
       (getpos ghosts)))
   ;; ghostdist: given list of ghost statuses and a position, return list of (manhattandistance, directions) tuples
   ;;            note: the direction is the direction away from the ghost
   (lambda (gl pos)
     (letrec (getmdd)
       ((lambda (g)
          (if (atom g)
              g
            (cons (tuple (mhdist (car g) pos) (dirfrom (car g) pos))
                  (getmdd (cdr g) pos)))))
       (getmdd gl pos)))
   ;; flee: given the world state, returns the direction tuple to flee or -1 if there is no need to flee
   (lambda (ws)
     (letrec (getdir)
       ((lambda (g)
          (if (atom g)
              -1
            (if (< (car (car g)) 4) ;; flee if ghost is closer than this
                (cdr (car g))
              (getdir (cdr g))))))
       (getdir (ghostdist (ghostpos ws) (lmanpos ws)))))
   ;; moves: given world state, returns a list of map objects and their directions (walls are excluded)
   (lambda (ws)
     (letrec (getobjs)
       ((lambda (dirs)
          (if (atom dirs)
              dirs
            (let (obj) ((mapobj (map ws) (nextstep (lmanpos ws) (car dirs))))
                 (if (eq obj 0)
                     (getobjs (cdr dirs))
                   (cons (tuple obj (car dirs))
                         (getobjs (cdr dirs))))))))
       (getobjs (list 0 1 2 3))))
   ;; sort: bubble-sorts a list using the supplied predicate
   ;;       adapted from: http://www.cs.toronto.edu/~dianaz/Example_LispPart1.html
   (lambda (unsorted predicate)
     (letrec (dosort checkagain)
       ((lambda (lst pred)
          ; Boundary case, if the input is an nil list
          (if (atom lst)
              lst
            ; Base case, if the list contains 1 number
            (if (atom (cdr lst))
                lst
              ; Recursive case, check the first bubble -- the first two numbers in the list
              ; If the first number <= second number, sort the list starting at the second number
              ; Beware that the recursive call to sort can return a list with the first number smaller
              ; than the current first number in the list. Hence, call a function 'check-again' to ensure
              ; the list is correctly sorted. This is what the bubble sort do when flipping the numbers among 
              ; bubbles.
              (if (pred (car lst) (car (cdr lst)))
                  (checkagain
                   (cons (car lst)
                         (dosort (cdr lst) pred))
                   pred)
                ; If the first number > second number, swap the first two numbers and sort the list
                ; starting at the current second number
                (checkagain
                 (cons (car (cdr lst))
                       (dosort (cons (car lst) (cdr (cdr lst))) pred))
                 pred)))))
        (lambda (lst pred)
          (if (pred (car lst) (car (cdr lst)))
              lst
            (dosort lst pred))))
       (dosort unsorted predicate)))
   ;; transform: transforms list of (obj dir) to a list of (desirability dir)
   (lambda (movelist)
     (letrec (dotrans transform)
       ((lambda (lst)
          (if (atom lst)
              lst
            (cons (transform (car lst)) (dotrans (cdr lst)))))
        (lambda (a)
          (let (obj dir) ((car a) (cdr a))
               (if (eq obj 4)
                   (cons 10 dir)
                 (if (eq obj 3)
                     (cons 20 dir)
                   (if (eq obj 2)
                       (cons 30 dir)
                     (if (eq obj 1)
                         (cons 40 dir)
                       (if (eq obj 5)
                           (cons 40 dir) ; treat as empty
                         (if (eq obj 6)
                             (cons 40 dir) ; treat as empty
                           (cons 70 dir))))))))))
        (dotrans movelist)))
   ;; sortedmoves: given list of moves, sort them in (fruit, power pill, pill, (empty, lambda-man-start, ghost-start), wall) order
   (lambda (movelist)
     (letrec (pred)
       ((lambda (a b)
          (<= (car a) (car b))))
       (sort (transform movelist) pred)))
   ;; filterdir: given list of moves and a dir, return list without it
   (lambda (movelist dir)
     (letrec (dofilter)
       ((lambda (lst)
          (if (atom lst)
              lst
            (if (eq (cdr (car lst)) dir)
                (dofilter (cdr lst))
              (cons (car lst) (dofilter (cdr lst)))))))
       (dofilter movelist)))
   ;; filterobj: given list of moves and an obj, return list without it
   (lambda (movelist obj)
     (letrec (dofilter)
       ((lambda (lst)
          (if (atom lst)
              lst
            (if (eq (car (car lst)) obj)
                (dofilter (cdr lst))
              (cons (car lst) (dofilter (cdr lst)))))))
       (dofilter movelist)))
   ;; findpills: given ws, returns how many there are in each direction
   (lambda (ws)
     (letrec (sumdir getdists getpills)
       ((lambda (pills dir)
          (letrec (dosumdir)
            ((lambda (lst c)
               (if (atom lst)
                   c
                 (if (eq dir 0) ;; up
                     (if (> (cdr (car lst)) 0)
                         (dosumdir (cdr lst) (+ c 1))
                       (dosumdir (cdr lst) c))
                   (if (eq dir 1) ;; right
                       (if (< (car (car lst)) 0)
                           (dosumdir (cdr lst) (+ c 1))
                         (dosumdir (cdr lst) c))
                     (if (eq dir 3) ;; down
                         (if (< (cdr (car lst)) 0)
                             (dosumdir (cdr lst) (+ c 1))
                           (dosumdir (cdr lst) c))
                       (if (eq dir 0) ;; left
                           (if (> (cdr (car lst)) 0)
                               (dosumdir (cdr lst) (+ c 1))
                             (dosumdir (cdr lst) c))
                         ;; this should never happen!
                         c)))))))
            (dosumdir pills 0)))
        (lambda (p)
          (letrec (lmp dodist)
            ((lmanpos ws)
             (lambda (lst)
               (if (atom lst)
                   lst
                 (cons (cons (- (car lmp) (car (car lst)))
                             (- (cdr lmp) (cdr (car lst))))
                       (dodist (cdr lst))))))
            (dodist p)))
        (lambda (m)
          (letrec (walky walkx)
            ((lambda (rows y pills)
               (if (atom rows)
                   pills
                 (let (newpills) ((walkx (car rows) 0 y pills))
                      (walky (cdr rows) (+ y 1) newpills))))
             (lambda (row x y pills)
               (if (atom row)
                   pills
                 (if (eq (car row) 2)
                     (cons (cons x y) (walkx (cdr row) (+ x 1) y pills))
                   (walkx (cdr row) (+ x 1) y pills)))))
            (walky m 0 0))))
          (let (dists) ((getdists (getpills (map ws))))
               (list (cons 0 (sumdir dists 0))
                     (cons 1 (sumdir dists 1))
                     (cons 2 (sumdir dists 2))
                     (cons 3 (sumdir dists 3))))))
   ;; sameasfirst: takes a list of moves, then returns the list of moves which has the same map object as the first and the length of it
   (lambda (movelist)
     (if (atom movelist)
         movelist
       (let (first) ((car (car movelist)))
            (letrec (filter)
              ((lambda (lst)
                 (if (atom lst)
                     lst
                   (if (eq (car (car lst)) first)
                       (cons (car lst) (filter (cdr lst)))
                     (filter (cdr lst))))))
              (filter movelist)))))
   ;; shuffle: takes a moves list, and returns a list randomized according to the weights
   (lambda (lst1 weights rndseed)
     (if (atom lst1)
         lst1
       (if (atom (cdr lst1)) ;; only one element, pointless to do anything
           lst1
         (letrec (doshuffle applyrandomizedweights getweight)
           ((lambda (movelist)
              (letrec (pred)
                ((lambda (a b)
                   (>= (car a) (car b))))
                (sort movelist pred)))
            (lambda (lst seed)
              (if (atom lst)
                  lst
                (let (w rnd) ((print (getweight weights (cdr (car lst)))) (random seed))
                     (cons (cons (modulo rnd (+ w 5)) (cdr (car lst))) ; Add some to w, to avoid divzerro and to give low values a bit higher chance
                           (applyrandomizedweights (cdr lst) rnd)))))
            (lambda (lst dir)
              (if (atom lst)
                  lst
                (if (eq (car (car lst)) dir)
                    (cdr (car lst))
                  (getweight (cdr lst) dir)))))
           (doshuffle (print (applyrandomizedweights lst1 rndseed)))))))
   ;; step: this is the main ai function, it takes the current ai state and the world state,
   ;; and returns the new ai state and the new direction for lambda-man
   (lambda (ai ws)
     (tuple (random ai)
            (let (fleedir movelist currdir rnd)
              ((flee ws) (print (sortedmoves (moves ws))) (print (lmandir ws)) (modulo ai 2))
                 (if (atom fleedir)
                     ;; No need to flee. Go to the first direction in the movelist
                     (if (atom movelist)
                         ;; OH NOES
                         currdir
                       (if (<= (car (car movelist)) 30) ; lower values are more desirable, if the top move is a pill or fruit, go for it!
                           (cdr (car movelist))
                         (let (filteredinit) ((sameasfirst (filterdir movelist (opposite currdir))))
                              (if (atom filteredinit)
                                  ;; No choice but to go back on ourselves
                                  (opposite currdir)
                                (let (filtered) ((if (eq (lmanvit ws) 0) (filterobj filteredinit 3) filteredinit))
                                     (if (atom filtered)
                                         ;; Ok, then eat the power..
                                         (cdr (car filteredinit))
                                       (if (atom (cdr filtered))
                                           ;; only one way to go!
                                           (cdr (car filtered))
                                         ;; Multiple choices, figure out where it's best to go!
                                         (let (pills) ((print (findpills ws)))
                                              (let (randomized) ((print (shuffle filtered pills ai)))
                                                   (cdr (car randomized)))))))))))
                   ;; Flee! But not into a wall!
                   (let (d1 d2) ((car fleedir) (cdr fleedir))
                        (let (dobj1 dobj2) ((mapobj (map ws) (nextstep (lmanpos ws) d1))
                                            (mapobj (map ws) (nextstep (lmanpos ws) d2)))
                             (if (eq dobj1 0)
                                 (if (eq dobj2 0)
                                     ;; aagh
                                     (opposite d1)
                                   d2)
                               d1)))
                   )
                 )
            )
     )
   ;; mapobj: access the map at a certain position
   (lambda (map pos)
     (let (x y) ((car pos) (cdr pos))
          (if (eq y 0)
              (findx (car map) x)
            (mapobj (cdr map) (tuple x (- y 1))))))
   ;; findx: helper for mapobj (could probably be local to mapobj)
   (lambda (row x)
     (if (eq x 0)
         (car row)
       (findx (cdr row) (- x 1))))
   ;; nextstep: given a position and a direction, it returns the new position
   (lambda (pos dir)
     (let (x y) ((car pos) (cdr pos))
          (if (eq dir 0)
              (tuple x (- y 1))
            (if (eq dir 1)
                (tuple (+ x 1) y)
              (if (eq dir 2)
                  (tuple x (+ y 1))
                (tuple (- x 1) y)))))))
  (init)
  )
